<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ“æŸ±é«”æ°´å¡”é«”ç©èˆ‡é‡é‡è¨ˆç®—å™¨ (å«ç„¡æ•ˆæ°´ä½)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f9;
        }
        .container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .left-panel, .right-panel {
            padding: 20px;
            border-radius: 8px;
            background-color: #ffffff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .left-panel {
            flex: 1; 
            max-width: 300px;
        }
        .right-panel {
            flex: 3; 
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .input-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="number"] {
            width: 90%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        #results-panel {
            padding: 20px;
            border-radius: 8px;
            background-color: #e9ecef;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .unit-selector {
            margin-top: 15px;
        }
        /* ç¢ºä¿ LaTeX å…¬å¼èƒ½æ­£ç¢ºé¡¯ç¤º */
        #volumeCalculationSteps .mjx-container {
            margin: 5px 0;
            display: block; 
            text-align: left;
            font-size: 1.1em;
            overflow-x: auto; /* é˜²æ­¢å…¬å¼å¤ªé•·æº¢å‡º */
            padding: 5px 0;
        }
        #volumeCalculationSteps h4 {
            margin-top: 0;
            color: #333;
        }
        /* çªå‡ºè¨ˆç®—æ­¥é©Ÿå€å¡Š */
        #volumeCalculationSteps .step-block {
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        .pre-calc {
            background-color: #f9f9f9; 
            border: 1px solid #ddd;
        }
        .calc-h1-h2 {
            background-color: #f0f8ff; 
            border: 1px solid #d0e8ff;
        }
        .final-calc {
            background-color: #e6ffe6; 
            border: 1px solid #c0ffc0;
        }
    </style>
</head>
<body>

    <h1>ğŸ’§ æ©«æ”¾åœ“æŸ±é«”æ°´å¡”é«”ç©èˆ‡é‡é‡è¨ˆç®—å™¨</h1>
    <div class="container">
        <div class="left-panel">
            <h2>åƒæ•¸è¼¸å…¥ (å–®ä½: cm)</h2>
            <div class="input-group">
                <label for="outerDiameter">å¤–å¾‘ (D):</label>
                <input type="number" id="outerDiameter" value="128" min="1" required>
            </div>
            <div class="input-group">
                <label for="thickness">æ°´å¡”åšåº¦ (t):</label>
                <input type="number" id="thickness" value="0.6" min="0" required>
            </div>
            <div class="input-group">
                <label for="length">æ°´å¡”é•·åº¦ (L):</label>
                <input type="number" id="length" value="220" min="1" required>
            </div>
            <div class="input-group">
                <label for="waterHeight">ç¸½æ°´ä½é«˜åº¦ ($h_1$):</label>
                <input type="number" id="waterHeight" value="98" min="0" required>
            </div>
            <div class="input-group">
                <label for="invalidHeight">ç„¡æ•ˆæ°´ä½é«˜åº¦ ($h_2$):</label>
                <input type="number" id="invalidHeight" value="5" min="0" required>
                <p style="font-size: 0.8em; margin: 5px 0 0 0;">(æ°´å¡”åº•éƒ¨ç„¡æ³•æ’å‡ºçš„æ­»æ°´å€)</p>
            </div>
            <button onclick="calculateAndDraw()">è¨ˆç®—èˆ‡ç¹ªè£½</button>
        </div>

        <div class="right-panel">
            <canvas id="tankCanvas" width="650" height="350"></canvas>
        </div>
    </div>

    <div id="results-panel">
        <h2>ğŸ“Š é«”ç©èˆ‡é‡é‡è¨ˆç®—éç¨‹</h2>
        <div id="volumeCalculationSteps">è«‹è¼¸å…¥åƒæ•¸ä¸¦é»æ“Šè¨ˆç®—æŒ‰éˆ•ã€‚</div>
        
        <div class="unit-selector">
            <label for="volumeUnit">é«”ç©å–®ä½ï¼š</label>
            <select id="volumeUnit" onchange="updateResults()">
                <option value="cm3">ç«‹æ–¹å…¬åˆ† ($\text{cm}^3$)</option>
                <option value="m3">ç«‹æ–¹å…¬å°º ($\text{m}^3$)</option>
                <option value="L">å…¬å‡ ($\text{L}$)</option>
                <option value="kL">å…¬ç§‰ ($\text{kL}$)</option>
            </select>
            <p><strong>æœ‰æ•ˆæ°´é«”ç© ($V_{\text{æœ‰æ•ˆ}}$)ï¼š</strong> <span id="displayVolume">0</span></p>
        </div>
        
        <hr>

        <div class="unit-selector">
            <label for="weightUnit">é‡é‡å–®ä½ï¼š</label>
            <select id="weightUnit" onchange="updateResults()">
                <option value="g">å…¬å…‹ ($\text{g}$)</option>
                <option value="kg">å…¬æ–¤ ($\text{kg}$)</option>
                <option value="t">å…¬å™¸ ($\text{t}$)</option>
            </select>
            <p style="margin-top: 5px; font-size: 0.9em;">*å‡è¨­æ°´çš„å¯†åº¦ç´„ç‚º $1 \text{ g/cm}^3$ã€‚</p>
            <p><strong>æ°´é‡é‡ ($W$)ï¼š</strong> <span id="displayWeight">0</span></p>
        </div>
    </div>

    <script>
        // å…¨åŸŸè®Šæ•¸ç”¨æ–¼å„²å­˜è¨ˆç®—çµæœ (ä»¥ cmÂ³ ç‚ºåŸºæº–)
        let calculatedVolumeCm3 = 0;
        
        /**
         * æ ¸å¿ƒå‡½æ•¸ï¼šè¨ˆç®—çµ¦å®šé«˜åº¦ $h$ çš„å¼“å½¢åº•é¢ç© ($A_h$)ã€‚
         * @param {number} R å…§åŠå¾‘ (cm)
         * @param {number} h å¼“å½¢é«˜åº¦ (cm)
         * @returns {number} é¢ç© (cmÂ²)
         */
        function getSegmentArea(R, h) {
            if (h <= 0 || R <= 0 || h > 2 * R) return 0;
            if (h === 2 * R) return Math.PI * R * R;
            
            // Formula: $A = R^2 \cdot \arccos(\frac{R-h}{R}) - (R-h) \cdot \sqrt{2Rh - h^2}$
            const discriminant = 2 * R * h - h * h;
            let area = 0;

            if (discriminant >= 0) {
                area = R * R * Math.acos((R - h) / R) - (R - h) * Math.sqrt(discriminant);
            }
            return area;
        }

        /**
         * ä¸»è¨ˆç®—å‡½æ•¸ï¼šè¨ˆç®—æœ‰æ•ˆæ°´é«”ç© $V_{\text{æœ‰æ•ˆ}} = V_{h_1} - V_{h_2}$
         * @param {number} R å…§åŠå¾‘
         * @param {number} h1 ç¸½æ°´ä½é«˜åº¦
         * @param {number} h2 ç„¡æ•ˆæ°´ä½é«˜åº¦
         * @param {number} L æ°´å¡”é•·åº¦
         * @returns {object} åŒ…å«æœ‰æ•ˆé«”ç©å’Œæ­¥é©Ÿ
         */
        function calculateWaterVolume(R, h1, h2, L) {
            if (h1 < 0 || h2 < 0 || R <= 0 || L <= 0) return { volume: 0, steps: "è¼¸å…¥åƒæ•¸ç„¡æ•ˆã€‚" };

            // åƒæ•¸æ ¡é©—
            h1 = Math.min(h1, 2 * R); 
            h2 = Math.min(h2, h1);    
            
            // 1. Calculate Areas (è¨ˆç®—å¼“å½¢åº•é¢ç©)
            const A_h1 = getSegmentArea(R, h1);
            const A_h2 = getSegmentArea(R, h2);

            // 2. Calculate Volumes (è¨ˆç®—é«”ç© $V = A \cdot L$)
            const V_h1 = A_h1 * L;
            const V_h2 = A_h2 * L;

            // 3. Calculate Effective Volume
            const volume = V_h1 - V_h2;
            
            // --- æ­¥é©Ÿè¼¸å‡º ---
            const R_fixed = R.toFixed(2);
            const L_fixed = L.toFixed(2);
            const h1_fixed = h1.toFixed(2);
            const h2_fixed = h2.toFixed(2);
            
            const A_h1_fixed = A_h1.toFixed(2);
            const V_h1_fixed = V_h1.toFixed(2);
            const A_h2_fixed = A_h2.toFixed(2);
            const V_h2_fixed = V_h2.toFixed(2);
            const volume_fixed = volume.toFixed(2);
            
            let steps = `
            <div class="step-block calc-h1-h2">
                <h4>æ­¥é©Ÿä¸€ï¼šè¨ˆç®—æ°´çš„ã€Œå¼“å½¢åº•é¢ç©ã€ ($A_{h}$)</h4>
                <p>æ°´çš„åº•é¢ç©å°±æ˜¯åœ“å½¢æˆªé¢ä¸­ï¼Œè¢«æ°´ä½ç·šæˆªå‡ºçš„å¼“å½¢é¢ç©ã€‚$$A = \\text{æ‰‡å½¢é¢ç©} - \\text{ä¸‰è§’å½¢é¢ç©}$$</p>
                
                <p>1. **ç¸½æ°´ä½åº•é¢ç© ($A_{h_1}$)ï¼š** (æ°´ä½ $h_1 = ${h1_fixed} \text{ cm}$)</p>
                $$\\text{å¼“å½¢é¢ç© } A_{h_1} \\approx ${A_h1_fixed} \\text{ cm}^2$$

                <p>2. **ç„¡æ•ˆæ°´ä½åº•é¢ç© ($A_{h_2}$)ï¼š** (æ°´ä½ $h_2 = ${h2_fixed} \text{ cm}$)</p>
                $$\\text{å¼“å½¢é¢ç© } A_{h_2} \\approx ${A_h2_fixed} \\text{ cm}^2$$
            </div>
            
            <div class="step-block final-calc">
                <h4>æ­¥é©ŸäºŒï¼šè¨ˆç®—æœ‰æ•ˆé«”ç© ($V = A \\cdot L$)</h4>
                <p>æœ‰æ•ˆé«”ç© $V_{\\text{æœ‰æ•ˆ}}$ ç­‰æ–¼æ°´çš„åº•é¢ç©ä¹˜ä»¥æ°´å¡”é•·åº¦ $L = ${L_fixed} \text{ cm}$</p>
                
                <p>1. **ç¸½æ°´é«”ç© $V_{h_1}$ï¼š** (åº•é¢ç© $\\times$ é•·åº¦)</p>
                $$V_{h_1} = A_{h_1} \\cdot L = ${A_h1_fixed} \\cdot ${L_fixed} \\approx ${V_h1_fixed} \\text{ cm}^3$$
                
                <p>2. **ç„¡æ•ˆæ°´é«”ç© $V_{h_2}$ï¼š**</p>
                $$V_{h_2} = A_{h_2} \\cdot L = ${A_h2_fixed} \\cdot ${L_fixed} \\approx ${V_h2_fixed} \\text{ cm}^3$$

                <p>3. **æœ‰æ•ˆé«”ç© $V_{\\text{æœ‰æ•ˆ}}$ï¼š** ($V_{h_1} - V_{h_2}$)</p>
                $$V_{\\text{æœ‰æ•ˆ}} = ${V_h1_fixed} - ${V_h2_fixed} \\approx ${volume_fixed} \\text{ cm}^3$$
                <p style="font-size: 0.9em; margin-top: 15px;">*è¨»ï¼šå¼“å½¢é¢ç©å…¬å¼ï¼š$$A = R^2 \\cdot \\arccos \\left(\\frac{R-h}{R}\\right) - (R-h) \\cdot \\sqrt{2Rh - h^2}$$</p>
            </div>`;
            
            return { volume: volume, steps: steps };
        }
        
        /**
         * å–®ä½è½‰æ›å‡½æ•¸ (ä¿æŒä¸è®Š)
         */
        function convertVolume(volumeCm3, unit) {
            switch (unit) {
                case 'cm3': return volumeCm3;
                case 'm3': return volumeCm3 / 1000000;
                case 'L': return volumeCm3 / 1000;
                case 'kL': return volumeCm3 / 1000000;
                default: return volumeCm3;
            }
        }
        function convertWeight(volumeCm3, unit) {
            const weightGrams = volumeCm3 * 1;
            switch (unit) {
                case 'g': return weightGrams;
                case 'kg': return weightGrams / 1000;
                case 't': return weightGrams / 1000000;
                default: return weightGrams;
            }
        }
        
        /**
         * ç¹ªè£½æ°´å¡”å’Œæ°´ä½çš„è¦–è¦ºåŒ–åœ–å½¢ (ä¿æŒä¸è®Š)
         */
        function drawTank(D, L_cm, h1, h2) {
            const canvas = document.getElementById('tankCanvas');
            const ctx = canvas.getContext('2d');
            const W = canvas.width;
            const H = canvas.height;
            ctx.clearRect(0, 0, W, H);
            
            // --- ç¹ªåœ–æ¯”ä¾‹å°ºè¨­å®š ---
            const maxL_px = W * 0.7;
            const maxD_px = H * 0.6;
            
            const SCALE_FACTOR = Math.min(maxL_px / L_cm, maxD_px / D);

            const Radius_px = D / 2 * SCALE_FACTOR; 
            const Length_px = L_cm * SCALE_FACTOR; 
            const h1_px = h1 * SCALE_FACTOR; 
            const h2_px = h2 * SCALE_FACTOR;

            const R_out_px = Radius_px;

            const startX = (W - Length_px) / 2;
            const endX = startX + Length_px;
            const centerY = H - R_out_px - 80; 

            const tankTopY = centerY - R_out_px;
            const tankBottomY = centerY + R_out_px;
            
            // --- ç¹ªè£½æ”¯æ¶ ---
            const standHeight = 40; 
            const standY_top = tankBottomY;
            const standY_bottom = standY_top + standHeight;

            ctx.strokeStyle = '#000000'; 
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(startX, standY_bottom);
            ctx.lineTo(endX, standY_bottom);
            ctx.stroke();
            
            const supportX_left = startX + Length_px * 0.15;
            const supportX_right = endX - Length_px * 0.15;
            
            ctx.beginPath();
            ctx.moveTo(supportX_left, standY_top);
            ctx.lineTo(supportX_left, standY_bottom);
            ctx.moveTo(supportX_right, standY_top);
            ctx.lineTo(supportX_right, standY_bottom);
            ctx.stroke();

            // --- ç¹ªè£½æ°´å¡”æœ¬é«”æ¡†æ¶ ---
            ctx.strokeStyle = '#000000'; 
            ctx.lineWidth = 3;
            ctx.fillStyle = '#FFFFFF'; 

            ctx.beginPath();
            ctx.rect(startX, tankTopY, Length_px, 2 * R_out_px);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(startX, centerY, R_out_px, 0, 2 * Math.PI); 
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(endX, centerY, R_out_px, 0, 2 * Math.PI); 
            ctx.stroke();
            
            const capRadius = R_out_px * 0.15;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(startX + Length_px / 2, tankTopY, capRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // --- ç¹ªè£½æ°´é«” ---
            if (h1_px > 0) {
                const waterLevelY = tankBottomY - h1_px; 
                
                // --- ç¹ªè£½ç¸½æ°´é«”ç© (V_h1) ---
                
                // è¼”åŠ©è¨ˆç®—å‡½æ•¸: ç¹ªè£½ç‰¹å®šé«˜åº¦çš„å¼“å½¢é«”ç©
                const drawSegment = (h_draw, fillStyle) => {
                    if (h_draw <= 0) return;
                    const levelY = tankBottomY - h_draw;
                    ctx.fillStyle = fillStyle;

                    // ç¢ºä¿ d_px >= 0
                    const d_px = Math.max(0, R_out_px - h_draw); 
                    const halfChord = Math.sqrt(R_out_px * R_out_px - d_px * d_px); 
                    
                    // ä¸­é–“çŸ©å½¢
                    ctx.beginPath();
                    ctx.rect(startX, levelY, Length_px, h_draw);
                    ctx.fill();
                    
                    // å…©ç«¯å¼“å½¢
                    const angle = Math.acos(d_px / R_out_px); 
                    const startAngle = angle; 
                    const endAngle = 2 * Math.PI - angle; 
                    
                    // å·¦ç«¯å¼“å½¢
                    ctx.beginPath();
                    // Move to the point on the chord
                    ctx.moveTo(startX, levelY); 
                    ctx.arc(startX, centerY, R_out_px, startAngle, endAngle, false); 
                    ctx.lineTo(startX, levelY); // Back to start point of chord
                    ctx.closePath();
                    ctx.fill();
                    
                    // å³ç«¯å¼“å½¢
                    ctx.beginPath();
                    ctx.moveTo(endX, levelY);
                    ctx.arc(endX, centerY, R_out_px, startAngle, endAngle, false);
                    ctx.lineTo(endX, levelY);
                    ctx.closePath();
                    ctx.fill();
                };

                // 1. å…ˆç¹ªè£½ç¸½æ°´é«” (æ°´è—è‰²)
                drawSegment(h1_px, 'rgba(0, 191, 255, 0.7)');

                // 2. ç¹ªè£½ç„¡æ•ˆæ°´é«” (æ·±ç°è‰²/é™°å½±ï¼Œç–Šåœ¨æ°´è—è‰²ä¹‹ä¸Š)
                if (h2_px > 0) {
                    drawSegment(h2_px, 'rgba(100, 100, 100, 0.6)');

                    // æ¨™ç¤ºç„¡æ•ˆæ°´ä½ $h_2$
                    const invalidLevelY = tankBottomY - h2_px;
                    ctx.strokeStyle = '#800000'; 
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.setLineDash([5, 2]);
                    ctx.moveTo(startX - 5, invalidLevelY);
                    ctx.lineTo(endX + 5, invalidLevelY);
                    ctx.stroke();
                    ctx.setLineDash([]); 

                    ctx.fillStyle = '#800000'; 
                    ctx.textAlign = 'left';
                    ctx.fillText(`hâ‚‚ = ${h2.toFixed(1)} cm (ç„¡æ•ˆæ°´ä½)`, endX + 15, invalidLevelY + 5);
                }
                
                // 3. ç¹ªè£½ç¸½æ°´é¢ç·š (å¼·èª¿)
                ctx.strokeStyle = '#000080';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(startX, waterLevelY);
                ctx.lineTo(endX, waterLevelY);
                ctx.stroke();
            }
            
            // --- ç¹ªè£½æ¨™è¨»ç·šå’Œå°ºå¯¸ ---
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';

            // æ¨™ç¤ºé•·åº¦ L
            const textY_L = tankTopY - 20;
            ctx.fillText(`L = ${L_cm} cm`, startX + Length_px / 2, textY_L);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(startX, textY_L - 5);
            ctx.lineTo(endX, textY_L - 5);
            ctx.stroke();

            // æ¨™ç¤ºå…§å¾‘ D' (åœ¨å³å´)
            ctx.textAlign = 'left';
            const textX_D = endX + 15;
            ctx.fillText(`D' = ${D.toFixed(1)} cm`, textX_D, centerY + 5);
            ctx.beginPath();
            ctx.moveTo(textX_D - 5, tankTopY);
            ctx.lineTo(textX_D - 5, tankBottomY);
            ctx.stroke();

            // æ¨™ç¤ºç¸½æ°´ä½é«˜åº¦ h1 (åœ¨å·¦å´)
            ctx.textAlign = 'right';
            const textX_h = startX - 10;
            const current_h1 = h1 > 0 ? h1 : 0; 
            ctx.fillText(`hâ‚ = ${current_h1.toFixed(1)} cm (ç¸½é«˜)`, textX_h, tankBottomY - h1_px / 2 + 5);
            
            // è™›ç·šæ¨™ç¤º h1 ç¸½é«˜
            ctx.strokeStyle = '#000080';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.moveTo(startX, tankBottomY);
            ctx.lineTo(startX, tankBottomY - h1_px);
            ctx.stroke();
            ctx.setLineDash([]); 

        }
        
        /**
         * åŸ·è¡Œè¨ˆç®—ä¸¦æ›´æ–°ä»‹é¢ 
         */
        function calculateAndDraw() {
            const outerD = parseFloat(document.getElementById('outerDiameter').value);
            const thickness = parseFloat(document.getElementById('thickness').value);
            const L = parseFloat(document.getElementById('length').value);
            let h1 = parseFloat(document.getElementById('waterHeight').value);
            let h2 = parseFloat(document.getElementById('invalidHeight').value); 

            const innerD = outerD - 2 * thickness;
            const R = innerD / 2;
            
            if (R <= 0 || L <= 0) {
                alert("éŒ¯èª¤ï¼šå…§å¾‘å¿…é ˆå¤§æ–¼ 0ã€‚è«‹æª¢æŸ¥å¤–å¾‘å’Œåšåº¦ã€‚");
                return;
            }
            
            const maxH = innerD;
            if (h1 > maxH) {
                h1 = maxH;
                document.getElementById('waterHeight').value = h1;
            }
            if (h2 > h1) {
                h2 = h1;
                document.getElementById('invalidHeight').value = h2;
                alert("æ³¨æ„ï¼šç„¡æ•ˆæ°´ä½é«˜åº¦ä¸èƒ½è¶…éç¸½æ°´ä½é«˜åº¦ã€‚å·²è‡ªå‹•èª¿æ•´ hâ‚‚ã€‚");
            }
            
            const result = calculateWaterVolume(R, h1, h2, L);
            calculatedVolumeCm3 = result.volume;

            // ------------------ é«”ç©è¨ˆç®—éç¨‹å„ªåŒ–è¼¸å‡º ------------------
            const preCalculationHtml = `
                <p><strong>è¼¸å…¥åƒæ•¸ï¼š</strong>å¤–å¾‘ $D = ${outerD} \text{ cm}$ï¼Œåšåº¦ $t = ${thickness} \text{ cm}$ï¼Œé•·åº¦ $L = ${L} \text{ cm}$ï¼Œç¸½æ°´ä½ $h_1 = ${h1} \text{ cm}$ï¼Œç„¡æ•ˆæ°´ä½ $h_2 = ${h2} \text{ cm}$</p>
                <div class="step-block pre-calc">
                    <h4>ğŸ“ å‰ç½®è¨ˆç®— (æ°´å¡”å…§éƒ¨å°ºå¯¸)</h4>
                    <p>å…§å¾‘ $D' = D - 2t = ${innerD.toFixed(2)} \text{ cm}$</p>
                    <p>å…§åŠå¾‘ $R = D'/2 = ${R.toFixed(2)} \text{ cm}$</p>
                </div>`;
                
            const resultsHtml = preCalculationHtml + result.steps;
            document.getElementById('volumeCalculationSteps').innerHTML = resultsHtml;
            // --------------------------------------------------------

            updateResults();
            drawTank(innerD, L, h1, h2); 
            
            // ç¢ºä¿ MathJax é‡æ–°æ¸²æŸ“æ–°çš„å…¬å¼
            MathJax.typesetPromise();
        }

        /**
         * æ ¹æ“šé¸å®šçš„å–®ä½æ›´æ–°é«”ç©å’Œé‡é‡çš„é¡¯ç¤ºå€¼ 
         */
        function updateResults() {
            const volumeUnit = document.getElementById('volumeUnit').value;
            const weightUnit = document.getElementById('weightUnit').value;

            const displayV = convertVolume(calculatedVolumeCm3, volumeUnit);
            document.getElementById('displayVolume').textContent = `${displayV.toFixed(3)} ${volumeUnit}`;

            const displayW = convertWeight(calculatedVolumeCm3, weightUnit);
            document.getElementById('displayWeight').textContent = `${displayW.toFixed(3)} ${weightUnit}`;
        }

        // é é¢è¼‰å…¥å®Œæˆå¾ŒåŸ·è¡Œ
        window.onload = () => {
             // è¼‰å…¥ MathJax è…³æœ¬ç”¨æ–¼æ¸²æŸ“ LaTeX å…¬å¼
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
            script.async = true;
            document.head.appendChild(script);

            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']]
                },
                chtml: {
                    scale: 0.9 
                }
            };
            
            calculateAndDraw();
        };

    </script>
</body>
</html>